{"pages":[],"posts":[{"title":"两数相加","text":"题目描述： 两个字符串（数字可能超过安全数字）相加，可以假设字符串除了0之外，不会以0开头 eg: str1 str2 ouput 999 111 1110 99 1 100 8 22 30 解法注意： 两数相加时候的进位，最好加完之后的进位 12345678910111213141516171819202122/** * @description 两个字符串（数字可能超过安全数字）相加，可以假设字符串除了0之外，不会以0开头 * @param {string} str1 * @param {string} str2 * @returns {string} */function addTowStrings(str1: string, str2: string): string { let str1Len = str1.length - 1; let str2Len = str2.length - 1; let ret = \"\"; let carry = 0; while (str1Len &gt;= 0 || str2Len &gt;= 0) { const s1 = str1Len &gt;= 0 ? str1[str1Len] : 0; const s2 = str2Len &gt;= 0 ? str2[str2Len] : 0; const num = +s1 + +s2 + carry; carry = Math.floor(num / 10); ret = `${num % 10}${ret}`; str1Len--; str2Len--; } return carry === 1 ? `1${ret}` : ret;} 参考链接两个字符串数字相加两数相加两数相加 II","link":"/2020/07/06/addTowStrings.html"},{"title":"执行上下文","text":"如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行。但是变量提升，函数提升应该怎么解释呢？这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”。 执行上下文JavaScript 引擎遇到以下代码时才会做“准备工作”： 全局代码：代码默认运行的环境，最先会进入到全局环境中 函数代码：在函数的局部环境中运行的代码 Eval代码：在Eval()函数中运行的代码 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution context，EC)”。 执行上下文栈由于有太多的执行上下文， JavaScript 引擎创建了执行上下文栈（Execution context stack，ECStack）来管理执行上下文。 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。 看一段代码： 123456789101112131415function fn1() { var fn1Context = 'fn1 context'; function fn2() { var fn2Context = 'fn2 context'; function fn3() { var fn3Context = 'fn3 context'; console.log(fn3Context); } fn3(); console.log(fn2Context); } fn2(); console.log(fn1Context); } fn1(); 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： 12345678910111213141516171819202122232425ECStack = [];// 伪代码// 在初始化代码时会先进入全局上下文中， 全局上下文压入栈ECStack.push(globalContext);// fn1()ECStack.push(&lt;fn1&gt; fn1Context);// fn1中竟然调用了fn2，还要创建fn2的执行上下文ECStack.push(&lt;fn2&gt; fn2Context);// 擦，fn2还调用了fn3！ECStack.push(&lt;fn3&gt; fn3Context);// fn3执行完毕ECStack.pop();// fn2执行完毕ECStack.pop();// fn1执行完毕ECStack.pop();// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext，在应用关闭时销毁 VO/AOVO(变量对象)创建执行上下文时与之关联的会有一个变量对象，该上下文中的所有变量和函数全都保存在这个对象中。 AO(活动对象)进入到一个执行上下文时，此执行上下文中的变量和函数都可以被访问到，可以理解为被激活 谈到了上下文的创建和执行，我们来看看EC建立的过程： 建立阶段：(函数被调用，但是还未执行函数中的代码) 1. 创建变量，参数，函数，arguments对象 2. 建立作用域链 3. 确定this的值 执行阶段：变量赋值，函数引用，执行代码执行上下文为一个对象，包含VO，作用域链和this 123executionContextObj = { this: {} } 具体过程： 找到当前上下文调用函数的代码 执行代码之前，先创建执行上下文 创建阶段： 1 创建变量对象(VO)： 1 创建arguments对象，检查当前上下文的参数，建立该对象下的属性和属性值 2 扫描上下文的函数申明： 1 每扫描到一个函数什么就会在VO里面用函数名创建一个属性，为一个指针，指向该函数在内存中的地址 2 如果函数名在VO中已经存在，对应的属性值会被新的引用覆盖 3 扫描上下文的变量申明： 每扫描到一个变量就会用变量名作为属性名，其值初始化为undefined 如果该变量名在VO中已经存在，则直接跳过继续扫描 2 初始化作用域链 3 确定上下文中this的指向 代码执行阶段 执行函数体中的代码，给VO中的变量赋值 看代码理解： 123456function foo(i) { var a = 'hello'; var b = function privateB() {}; function c() {} } foo(22); 调用foo(22)时创建上下文包括VO，作用域链，this值。以函数名作为属性值，指向该函数在内存中的地址；变量名作为属性名，其初始化值为undefined注意：函数申明先于变量申明 1234567891011121314fooExecutionContext = { variableObject: { arguments: { 0: 22, length: 1 }, i: 22, c: pointer to function c(), a: undefined, b: undefined }, scopeChain: { ... }, this: { ... } } 创建阶段结束后就会进入代码执行阶段，给VO中的变量赋值: 1234567891011121314fooExecutionContext = { variableObject: { arguments: { 0: 22, length: 1 }, i: 22, c: pointer to function c(), a: 'hello', b: pointer to function privateB() }, scopeChain: { ... }, this: { ... } } 变量提升12345678function foo() { console.log(f1); //f1() {} console.log(f2); //undefined var f1 = 'hosting'; var f2 = function() {} function f1() {} } foo(); 调用foo()时会创建VO，初始VO中变量值等有一系列的过程，所有变量初始化值为undefined，所以console.log(f2)的值为undefined。并且函数申明先于变量申明，所以console.log(f1)的值为f1()函数而不为hosting。 参考资料聊一聊javascript执行上下文","link":"/2019/08/01/ExecutionContext.html"},{"title":"闭包","text":"闭包的概念来自维基百科的定义：在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。 以下例子就是闭包： 12345678910function makeFunc() { const name = \"closure\"; function getName() { return name; } return getName;}const myFunc = makeFunc();myFunc(); // closure 闭包的用处闭包常见的用法，就将围绕这些特点展开。注意：闭包封住了变量作用域，有效地防止了全局污染；但同时，它也存在内存泄漏的风险 模仿块级作用域现在有let和const，就不举例子了。 存储变量，缓存数据123456789101112function mockData() { const mem = {}; return { clear: () =&gt; (mem = null), // 显式暴露清理接口 get: page =&gt; { if (page in mem) { return mem[page]; } mem[page] = Math.random(); } };} 封装私有变量 思考题如果你完成下面的题，应该就算理解闭包的运行机制了。 下面的输出都是3，请改成输出 0，1，21234567891011var data = [];for (var i = 0; i &lt; 3; i++) { data[i] = function () { console.log(i); };}data[0](); // 3data[1](); // 3data[2](); // 3 答案12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) { data[i] = (function(i) { return function(){ console.log(i); } })(i)}data[0](); // 0data[1](); // 1data[2](); // 2 解释12345678910111213141516171819var nAdd;var t = function() { var n = 99; nAdd = function() { n++; } var t2 = function() { console.log(n) } return t2;};var a1 = t();var a2 = t();nAdd();a1(); //99a2(); //100","link":"/2019/07/30/closures.html"},{"title":"柯里化（curry）","text":"柯里化的概念 In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.by wikipedia 把接受多个参数的函数变换成一系列接受单一参数（从最初函数的第一个参数开始）的函数的技术。（注意是单一参数） 12345678910import { curry } from 'lodash'const add = (x, y) =&gt; x + yconst curriedAdd = curry(add)const increment = curriedAdd(1)const addTen = curriedAdd(10)increment(2) // 3addTen(2) // 12 柯里化 VS 偏函数应用（partial application） In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity.by wikipedia 偏函数应用简单来说就是：一个函数，接受一个多参数的函数且传入部分参数后，返回一个需要更少参数的新函数。柯里化一般和偏函数应用相伴出现，但这两者是不同的概念： 12345678import { curry, partial } from 'lodash'const add = (x, y, z) =&gt; x + y + zconst curriedAdd = curry(add) // &lt;- 只接受一个函数const addThree = partial(add, 1, 2) // &lt;- 不仅接受函数，还接受至少一个参数 === curriedAdd(1)(2) // &lt;- 柯里化每次都返回一个单参函数 简单来说，一个多参函数（n-ary），柯里化后就变成了 n * 1-ary，而偏函数应用了 x 个参数后就变成了 (n-x)-ary 柯里化的实现虽然从理论上说柯里化应该返回的是一系列的单参函数，但在实际的使用过程中为了像偏函数应用那样方便的调用，所以这里柯里化后的函数也能接受多个参数。 1234567891011// 实现一个函数 curry 满足以下调用、const f = (a, b, c, d) =&gt; { ... }const curried = curry(f)curried(a, b, c, d)curried(a, b, c)(d)curried(a)(b, c, d)curried(a, b)(c, d)curried(a)(b, c)(d)curried(a)(b)(c, d)curried(a, b)(c)(d) 很明显第一反应是需要使用递归，这样才能返回一系列的函数。而递归的结束条件就是接受了原函数数量的参数，所以重点就是参数的传递~ 12345678910111213141516171819202122232425// ES5var curry = function curry (fn, arr) { arr = arr || [] return function () { var args = [].slice.call(arguments) var arg = arr.concat(args) return arg.length &gt;= fn.length ? fn.apply(null, arg) : curry(fn, arg) }}// ES6const curry = (fn, arr = []) =&gt; (...args) =&gt; ( arg =&gt; arg.length &gt;= fn.length ? fn(...arg) : curry(fn, arg))([...arr, ...args])const curry1 = (fn, arr) =&gt; (...args) =&gt; { const arg = [...arr, ...args]; return arg.length &gt;= fn.length ? fn(...arg) : curry1(fn, arg)}","link":"/2019/09/06/curry.html"},{"title":"【日期】时间格式化","text":"题目描述：给定一个时间，按照指定格式返回 eg: time format output 2019-02-02 12:21:21 yyyy-MM-dd 2019-02-02 2019-02-02 12:21:21 yyyy-M-d 2019-2-2 2019-02-02 12:21:21 yyyy-MM-dd 2019-02-02 2019-02-02 12:21:21 yyyy年M月d日 2019年2月2日 2019-02-02 12:21:21 yyyy-MM-dd hh:mm 2019-02-02 12:21 题解123456789101112131415161718192021222324252627282930313233343536/** * @description 日期格式化 * @param time string | number * @param format string \"yyyy-MM-dd hh:mm:ss\" * @returns 格式化时间 */function format(time: string | number, format: string = \"yyyy-MM-dd hh:mm:ss\"): string { const date = new Date(time); const o = { \"y+\": date.getFullYear(), \"M+\": date.getMonth() + 1, //月份 \"d+\": date.getDate(), //日 \"h+\": date.getHours(), //小时 \"m+\": date.getMinutes(), //分 \"s+\": date.getSeconds() //秒 }; for (const [key, value] of Object.entries(o)) { format = format.replace(new RegExp(key), match =&gt; { if (match.includes(\"y\")) { return `${value}` } return match.length === 1 ? `${value}` : value &lt; 10 ? `0${value}` : `${value}`; }); } return format;}console.log(format(Date.now()));console.log(format(\"2020-05-19 16:05:12\", \"yyyy-M\")); // 2020-5console.log(format(\"2020-05-19 16:05:12\", \"yyyy-MM\")); // 2020-05console.log(format(\"2020-05-19 16:05:12\", \"yyyy年M月\")); // 2020年5月console.log(format(\"2020-05-19 16:05:12\", \"yyyy年MM月\")); //2020年05月console.log(format(\"2020-05-19 16:05:12\", \"yyyy年M月d天\")); // 2020年5月19天console.log(format(\"2020-05-19 16:05:12\", \"yyyy-M-d\")); //2020-5-19console.log(format(\"2020-05-19 16:05:12\", \"yyyy-MM-d\")); //2020-05-19console.log(format(\"2020-05-19 16:05:12\", \"yyyy-MM-dd hh:mm\")); // 2020-05-19 16:05 参考链接日期格式化","link":"/2020/06/18/date-format.html"},{"title":"数字的千位分隔符表示法","text":"题目描述： 数字的千位分隔符表示法,多种实现方式。 eg: 输入 输出 10000000000 10,000,000,000 100000000000 100,000,000,000 100000000 100,000,000 解法 – 正则表达式 \\d{3}： 三个数为一组 (?=\\d{3})： (?=x) 匹配位置，匹配三个数字前面的位置 (?=\\d{3}$)： 匹配最后三个数前面的位置 (\\d{3})+： 一组三个数出现一次或者多次 (?=(\\d{3})+$)： 匹配多组三个数前面的位置 (?!^)： 匹配位置，匹配非 ^ 前面的位置，即此位置后面不匹配 ^ 注意： 开头一组三位数字前面。 12345678/** * @description 数字的千位分隔符表示法 * @param {number} num - 输入数字 * @returns {string} */function numformat1(num: number): string { return num.toLocaleString();} 解法 – toLocaleString具有多种数字格式化功能。参考链接：Number.prototype.toLocaleString()注意：当格式化大量数字时，最好建立一个 NumberFormat 对象并且使用它提供的 NumberFormat.format 方法。 12345678/** * @description 数字的千位分隔符表示法 * @param {number} num - 输入数字 * @returns {string} */function numformat1(num: number): string { return num.toLocaleString();} 解法 – 函数函数解法有各种写法，都要注意开头三位数情况，这里实现一个从后向前遍历，每三位数为一组。 1234567891011121314151617/** * @description 数字的千位分隔符表示法 * @param {number} num - 输入数字 * @returns {string} */function numformat2(num: number): string { const str = num.toString(); const arr = []; for (let len = str.length, i = len - 1; i &gt;= 0; i = i - 3) { let start = i - 2; if (start &lt; 0) { start = 0; } arr.push(str.slice(start, i + 1)); } return arr.reverse().join(',');} 参考链接数字的千位分隔符表示法","link":"/2020/06/28/numformat.html"},{"title":"偏函数(partial application)","text":"偏函数的概念维基百科中对偏函数 (Partial application) 的定义： In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. 翻译就是：在计算机科学中，部分应用（或部分功能应用）是指将一些参数固定到一个函数，产生另一个较小的arity函数的过程。 偏函数与bind函数bind()的一个最简单的用法是使一个函数拥有预设的初始参数。只要将这些参数（如果有的话）作为bind()的参数写在this后面。当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。 12345678910function list() { return Array.prototype.slice.call(arguments);}// 创建一个函数，它拥有预设参数列表。const leadingThirtysevenList = list.bind(null, 37);leadingThirtysevenList(); // [37]leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3] 然而使用 bind 会改变了 this 指向，我们要写一个不改变 this 指向的方法，即偏函数。 Partial application12345function partial(fn, ...argsBound) { return function(...args) { return fn.call(this, ...argsBound, ...args); };} 验证 this 指向的 demo 1234567891011121314function add(a, b) { return a + b + this.value;}// const addOne = add.bind(null, 1);const addOne = partial(add, 1);const value = 1;const obj = { value: 2, addOne: addOne}obj.addOne(2); // ???// 使用 bind 时，结果为 4// 使用 partial 时，结果为 5 partial 函数占位符提供占位符，可以等到需要时使用，例如当前还不知道需要传的的具体值时候，可以用一个占位符 12345678910const PLACEHOLDER = Symbol('PLACEHOLDER');function partial(fn, ...argsBound) { return function(...args) { let position = 0, len = argsBound.length; for(var i = 0; i &lt; len; i++) { argsBound[i] = argsBound[i] === PLACEHOLDER ? args[position++] : argsBound[i] } return fn.call(this, ...argsBound, ...args.slice(position)); };} 我们验证一下 123const subtract = function(a, b) { return b - a; };const subFrom20 = partial(subtract, PLACEHOLDER, 20);subFrom20(5); //15","link":"/2019/09/05/partial.html"},{"title":"原型与原型链","text":"理解原型无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor (构造函数)属性，这个属性包含一个指向 prototype 属性所在函数的指针。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针(内部 属性)，指向构造函数的原型对象。 prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： 1234567function Person() {}// prototype是函数才会有的属性Person.prototype.name = 'test';var person = new Person();console.log(person.name) // test 让我们用一张图表示构造函数和实例原型之间的关系： constructor在默认情况下，所有原型对象都会自动获得一个 constructor (构造函数)属性，这个属性包含一个指向 prototype 属性所在函数的指针: proto(内部属性)每个实例对象都有一个私有属性，称之为 __proto__（浏览器实现），指向它的构造函数的原型对象 注： Object.getPrototypeOf(person)可以得到实例对象的原型对象 原型链简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。而所有函数的原型对象都是 Object 的实例，因此原型对象都会包含一个内部指针，指向 Object.prototype。 完整的原型链如下图所示： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 123456789function Person() {}// prototype是函数才会有的属性Person.prototype.name = 'test';var person = new Person();person.name = 'person';console.log(person.name); // persondelete person.name;console.log(person.name); // test","link":"/2019/08/29/prototype.html"},{"title":"作用域与作用域链","text":"作用域作用域是指程序源代码中定义变量的区域。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 123456789101112var value = 1;function foo() { console.log(value);}function bar() { var value = 2; foo();}bar();// 结果是 1 下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 12345678910var value = 1;function foo() { console.log(value);}function bar() { var value = 2; foo();}bar(); 函数创建时，各自的[[scope]]为： 123456789101112131415foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ globalContext.VO];``` ### 函数激活当函数激活时，进入函数上下文，创建 `VO/AO` 后，就会将活动对象添加到作用链的前端。这时候执行上下文的作用域链，我们命名为 `Scope`：```jsScope = [AO].concat([[Scope]]); 在 bar函数执行时，bar的上下文对象如下: 123456barContext = { AO:{ value: 2 }, Scope: [barContext.AO,globalContext.VO]} 在 foo函数执行时，foo的上下文对象如下: 1234567fooContext = { AO:{}, Scope: [fooContext.AO,globalContext.VO]}value的查找过程：- fooContext.AO//没有找到- globalContext.VO //找到 10 参考资料JS中的作用域链是在什么时候建立的？JavaScript深入之作用域链","link":"/2019/07/31/scope.html"},{"title":"【日期】显示友好的时间格式","text":"题目描述： 给定一个时间，返回友好的时间提示【刚刚（0-59s），xx分钟前，xx小时前，xx天前，如果时间在太长，则显示xxxx年xx月xx日xx时xx分xx秒格式 】 题解普通判断解法123456789101112131415161718192021222324252627282930313233343536373839/** * @description js 显示友好的时间格式【刚刚（0-59s），几分钟前，几小时前，几天前（3天内），xxxx年xx月xx日xx时xx分xx秒 时间格式化】 * @param time Date * @returns 刚刚（0-59s），几分钟前，几小时前，几天前（3天内），xxxx年xx月xx日xx时xx分xx秒 */function timeToDate(time: number | string): string { const nowTime = Math.trunc(new Date().getTime() / 1000); const date = new Date(time) const diffTime = nowTime - Math.trunc(date.getTime() / 1000); const m = 60; const h = m * 60; const d = h * 24; if (diffTime &lt; 0) { return } if (diffTime &gt;= 0 &amp;&amp; diffTime &lt; m) { return \"刚刚\" } if (diffTime / m &lt; 60) { return Math.trunc(diffTime / m) + \"分钟前\"; } if (diffTime / h &lt; 24) { return Math.trunc(diffTime / h) + \"小时前\"; } if (diffTime / d &lt; 3) { return Math.trunc(diffTime / d) + \"天前\"; } return `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日${date.getHours()}时${date.getMinutes()}分${date.getSeconds()}秒`;}// console.log(timeToDate(\"2020-06-16 11:38:40\"));// console.log(timeToDate(new Date().getTime()));// console.log(timeToDate(\"2020-06-15 12:38:40\"));// console.log(timeToDate(\"2020-06-14 12:38:40\"));// console.log(timeToDate(\"2020-06-13 12:38:40\"));// console.log(timeToDate(\"2020-06-12 12:38:40\"));// console.log(timeToDate(\"2020-04-16 11:38:40\")); 扩展：方便添加显示效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function timeToDate(time: number | string) { const nowTime = Math.trunc(new Date().getTime() / 1000); const date = new Date(time) const diffTime = nowTime - Math.trunc(date.getTime() / 1000); if (diffTime &lt; 0) { return } if (diffTime &gt;= 0 &amp;&amp; diffTime &lt; 60) { return \"刚刚\" } const a = [ { type: \"min\", value: 60, result: 60, title: \"分钟前\" }, { type: \"hour\", value: 60 * 60, result: 24, title: \"小时前\" }, { type: \"day\", value: 60 * 60 * 24, result: 7, title: \"天前\" }, // { // type: \"week\", // value: 60 * 60 * 24 * 7, // result: 5, // title: \"周前\" // }, { type: \"mon\", value: 60 * 60 * 24 * 30, result: 12, title: \"月前\" }, { type: \"year\", value: 60 * 60 * 24 * 30 * 12, result: Infinity, title: \"年前\" } ] for (let i = 0, len = a.length; i &lt; len; i++) { const item = a[i]; if (diffTime / item.value &lt; item.result) { return Math.trunc(diffTime / item.value) + item.title; } } return `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日${date.getHours()}时${date.getMinutes()}分${date.getSeconds()}秒`;}console.log(timeToDate(\"2020-06-16 11:38:40\"));console.log(timeToDate(new Date().getTime()));console.log(timeToDate(\"2020-06-12 12:38:40\"));console.log(timeToDate(\"2020-06-11 12:38:40\"));console.log(timeToDate(\"2020-05-19 12:38:40\"));console.log(timeToDate(\"2020-04-16 11:38:40\"));console.log(timeToDate(\"2019-04-16 11:38:40\")); 设置xx时间之前显示友好效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172type Type = \"sec\" | \"min\" | \"hour\" | \"day\" | \"week\" | \"mon\" | \"year\";function timeToDate(time: number | string, type: Type = \"year\", duration: number = 3) { const nowTime = Math.trunc(new Date().getTime() / 1000); const date = new Date(time) const diffTime = nowTime - Math.trunc(date.getTime() / 1000); if (diffTime &lt; 0) { return } if (diffTime &gt;= 0 &amp;&amp; diffTime &lt; 60) { return \"刚刚\" } const a = [ { type: \"min\", value: 60, result: 60, title: \"分钟前\" }, { type: \"hour\", value: 60 * 60, result: 24, title: \"小时前\" }, { type: \"day\", value: 60 * 60 * 24, result: 7, title: \"天前\" }, { type: \"week\", value: 60 * 60 * 24 * 7, result: 5, title: \"周前\" }, { type: \"mon\", value: 60 * 60 * 24 * 30, result: 12, title: \"月前\" }, { type: \"year\", value: 60 * 60 * 24 * 30 * 12, result: Infinity, title: \"年前\" } ] for (let i = 0, len = a.length; i &lt; len; i++) { const item = a[i]; if (item.type === type) { if (diffTime / item.value &lt; item.result &amp;&amp; diffTime / item.value &lt; duration) { return Math.trunc(diffTime / item.value) + item.title; } break; } if (diffTime / item.value &lt; item.result) { return Math.trunc(diffTime / item.value) + item.title; } } return `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日${date.getHours()}时${date.getMinutes()}分${date.getSeconds()}秒`;}console.log(timeToDate(\"2020-06-16 11:38:40\"));console.log(timeToDate(new Date().getTime()));console.log(timeToDate(\"2020-06-12 12:38:40\"));console.log(timeToDate(\"2020-06-11 12:38:40\", \"day\", 3));console.log(timeToDate(\"2020-05-20 12:38:40\", \"week\", 5));console.log(timeToDate(\"2020-04-19 11:38:40\"));console.log(timeToDate(\"2019-04-16 11:38:40\")); 参考链接友好时间显示","link":"/2020/06/16/%E6%97%A5%E6%9C%9F%E5%8F%8B%E5%A5%BD%E6%98%BE%E7%A4%BA.html"}],"tags":[{"name":"执行上下文","slug":"执行上下文","link":"/tags/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"name":"闭包","slug":"闭包","link":"/tags/%E9%97%AD%E5%8C%85/"},{"name":"柯里化","slug":"柯里化","link":"/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"偏函数","slug":"偏函数","link":"/tags/%E5%81%8F%E5%87%BD%E6%95%B0/"},{"name":"原型与原型链","slug":"原型与原型链","link":"/tags/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"name":"作用域","slug":"作用域","link":"/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"JavaScript基础","slug":"JavaScript基础","link":"/categories/JavaScript%E5%9F%BA%E7%A1%80/"},{"name":"面试题","slug":"leetcode/面试题","link":"/categories/leetcode/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"编程题","slug":"编程题","link":"/categories/%E7%BC%96%E7%A8%8B%E9%A2%98/"},{"name":"面试题","slug":"编程题/面试题","link":"/categories/%E7%BC%96%E7%A8%8B%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]}